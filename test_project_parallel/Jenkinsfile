import groovy.json.JsonOutput

def artifactory_name = "Artifactory Docker"
def artifactory_repo = "hackathonv5-build"
def config_url = "https://github.com/demo-ci-conan/settings.git"
def remoteName = "artifactory-local"

def build_ref_with_lockfile(job_reference, lockfile, profile, config_url, artifactory_name, remoteName, artifactory_repo) {
    return {
        node {
            docker.image("conanio/gcc8").inside("--net=host") {
                try {
                    def server = Artifactory.server artifactory_name
                    def client = Artifactory.newConanClient()
                    
                    client.run(command: "config install ${config_url}".toString())
                    client.remote.add server: server, repo: artifactory_repo, remoteName: remoteName, force: true

                    def actual_reference_name = job_reference.split("/")[0]
                    def recipe_reference_with_revision = job_reference.split(":")[0]
                    def actual_reference = job_reference.split("#")[0]

                    stage("Build ${actual_reference_name}") {
                        unstash actual_reference_name

                        sh "cat ${actual_reference_name}.lock"
                        sh "cp ${actual_reference_name}.lock conan.lock"  // TODO: Have a look to this rename, shouldn't be needed
                        client.run(command: "install ${recipe_reference_with_revision} --build ${actual_reference} --lockfile conan.lock --profile ${profile}".toString())
                        sh "cp conan.lock ${actual_reference_name}.lock"
                        sh "cat ${actual_reference_name}.lock"
                        stash name: actual_reference_name, includes: "${actual_reference_name}.lock"
                    }

                    stage("Upload packages") {
                        String uploadCommand = "upload ${actual_reference} --all -r ${remoteName} --confirm"
                        client.run(command: uploadCommand)  // TODO: Better if we share the cache for these jobs... shouldn't have race conditions.
                    }
                }
                finally {
                    deleteDir()
                }
            }
        }
    }
}

def profile = "conanio-gcc8"
def lockfile = "conan.lock"
def build_order_file = "bo.json"

pipeline {
  agent any

  parameters {
    string(name: 'reference',   )
    string(name: 'project_id',  )
    string(name: 'organization',)
    string(name: 'repository',  )
    string(name: 'sha1',        )
  }

  stages {
    stage('Build information') {
      steps {
        script {
          echo "Building project '${params.project_id}'"
          echo " - for changes in '${params.reference}'"
        }
      }
    }
        
    stage('Dynamic node') {
      steps {
        script {
          docker.image("conanio/gcc8").inside("--net=host") {
            echo "Inside the docker"
            withEnv(["CONAN_USER_HOME=${env.WORKSPACE}/conan_home"]) {
              sh 'rm -rf "${CONAN_USER_HOME}"'
              echo "Create a Conan client (CONAN_USER_HOME: '${env.WORKSPACE}/conan_home')".toString()
              def server = Artifactory.server artifactory_name
              def client = Artifactory.newConanClient(userHome: "${env.WORKSPACE}/conan_home".toString())

              echo "Configure the Conan client"
              client.run(command: "config install ${config_url}".toString())
              //client.run(comamnd: "config get general.revisions_enabled")
              //client.run(command: "config get general.default_package_id_mode")
              client.remote.add server: server, repo: artifactory_repo, remoteName: remoteName, force: true

              echo "Install the reference"
              client.run(command: "install ${params.reference} --profile ${profile}".toString())
              client.run(command: "download ${params.project_id} -r ${remoteName}".toString())

              // TODO: Iterate profiles (can go in parallel)
              client.run(command: "graph lock --profile ${profile} --lockfile=${lockfile} ${params.project_id}".toString())
              sh "cat ${lockfile}"

              stash name: "lockfile", includes: "${lockfile}"
            }
          }
        }
      }
    }

    stage("Compute build order") {
      steps {
        script {
          docker.image("conanio/gcc8").inside("--net=docker_jenkins_artifactory") {
            unstash "lockfile"

            def server = Artifactory.server artifactory_name
            def client = Artifactory.newConanClient()
            client.run(command: "config install ${config_url}".toString())
            client.run(command: "config install -sf hooks -tf hooks https://github.com/conan-io/hooks.git")
            client.remote.add server: server, repo: artifactory_repo, remoteName: remoteName, force: true

            client.run(command: "graph build-order ${lockfile} --build missing --json ${build_order_file}".toString())
            sh "cat ${build_order_file}"

            stash name: "build_order", includes: "${build_order_file}"                
          }
        }
      }
    }

    stage("Iterate build order") {
      steps {
        script {
          unstash "lockfile"
          unstash "build_order"

          // Iterate build-order and call nodes
          def bo = readJSON file: build_order_file
          bo.each { it_stages ->

            def stage_lockfiles = []
            def stage_jobs = [:]
            for (int i = 0; i < it_stages.size(); i++) {
              def job_reference = it_stages[i][1]
              def actual_reference_name = job_reference.split("/")[0]
              
              sh "cp ${lockfile} ${actual_reference_name}.lock"
              stash name: actual_reference_name, includes: "${actual_reference_name}.lock"
              
              stage_lockfiles.add(actual_reference_name)
              stage_jobs[actual_reference_name] = build_ref_with_lockfile(job_reference, lockfile, profile, config_url, artifactory_name, remoteName, artifactory_repo)
            }

            stage ("Compile stage") {
              parallel stage_jobs
            }
            
            stage ("Complete lockfile") {
              docker.image("conanio/gcc8").inside("--net=docker_jenkins_artifactory") {
                unstash "lockfile"

                  for (int i = 0; i < stage_lockfiles.size(); i++) {
                    unstash stage_lockfiles[i]
                      sh "cat ${stage_lockfiles[i]}.lock"
                      sh "conan graph update-lock ${lockfile} ${stage_lockfiles[i]}.lock"
                      sh "cat ${lockfile}"
                  }

                stash name: "lockfile", includes: "${lockfile}"
              }
            }

          }

          unstash "lockfile"
          sh "cat ${lockfile}"

          sh 'false'
        }
      }
    }
  }
}
